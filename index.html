<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Messenger PRO</title>

<style>
:root{--accent:#2563eb;--bg:#f3f4f6}
*{box-sizing:border-box;font-family:Arial}
body{margin:0;background:var(--bg);height:100vh;display:flex}
.app{display:grid;grid-template-columns:280px 1fr;width:100%;padding:10px;gap:10px}
.panel{background:#fff;border-radius:10px;box-shadow:0 8px 25px rgba(0,0,0,.08);display:flex;flex-direction:column}
.top{padding:12px;border-bottom:1px solid #eee;font-weight:bold}
.contacts{flex:1;overflow:auto}
.contact{padding:10px;border-bottom:1px solid #eee;cursor:pointer;display:flex;justify-content:space-between}
.online{color:green;font-size:12px}
.offline{color:red;font-size:12px}
.messages{flex:1;padding:15px;overflow:auto}
.message{margin-bottom:6px;max-width:70%;padding:8px 10px;border-radius:8px;display:flex;flex-direction:column;gap:4px}
.me{background:#dbeafe;margin-left:auto;align-items:flex-end}
.them{background:#f1f5f9;align-items:flex-start}
.msg-time{font-size:10px;color:#94a3b8;white-space:nowrap}
.msg-media img,.msg-media video{max-width:260px;max-height:200px;border-radius:6px;display:block}
.msg-media audio{width:220px}
.composer{display:flex;padding:10px;border-top:1px solid #eee;gap:6px;align-items:center}
input{padding:8px;border-radius:6px;border:1px solid #ddd}
button{padding:8px 12px;border-radius:6px;border:none;cursor:pointer}
.primary{background:var(--accent);color:#fff}
.callBox{position:fixed;bottom:20px;right:20px;background:#fff;padding:15px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:none}

#incomingCall{
    position:fixed;inset:0;background:rgba(0,0,0,.55);
    display:none;align-items:center;justify-content:center;z-index:900;
}
#incomingBox{
    background:#fff;border-radius:16px;padding:28px 32px;
    box-shadow:0 12px 40px rgba(0,0,0,.25);text-align:center;
    display:flex;flex-direction:column;gap:14px;min-width:240px;
}
#incomingBox .caller{font-size:1.1rem;font-weight:bold;color:#111}
#incomingBox .sub{font-size:13px;color:#64748b}
.call-btns{display:flex;gap:10px;justify-content:center}
#acceptCall{background:#16a34a;color:#fff;padding:10px 22px;font-size:15px}
#acceptCall:hover{background:#15803d}
#rejectCall{background:#dc2626;color:#fff;padding:10px 22px;font-size:15px}
#rejectCall:hover{background:#b91c1c}

#authOverlay{
    position:fixed;inset:0;background:rgba(0,0,0,.45);
    display:flex;align-items:center;justify-content:center;
    z-index:1000;
}
#authBox{
    background:#fff;border-radius:12px;padding:32px 28px;
    box-shadow:0 12px 40px rgba(0,0,0,.25);width:320px;
    display:flex;flex-direction:column;gap:12px;
}
#authBox h2{margin:0;font-size:1.3rem;color:#111}
#authBox input{width:100%}
#authBox button.primary{width:100%;padding:10px}
#authError{color:#dc2626;font-size:13px;min-height:18px}
#authSwitch{font-size:13px;text-align:center;color:#555}
#authSwitch a{color:var(--accent);cursor:pointer;text-decoration:underline}

#myNickLabel{display:flex;justify-content:space-between;align-items:center}
#logoutBtn{font-size:12px;padding:4px 8px;background:#fee2e2;color:#dc2626;border-radius:5px;cursor:pointer;border:none}
#logoutBtn:hover{background:#fecaca}

#ctxMenu{
    position:fixed;background:#fff;border-radius:8px;
    box-shadow:0 4px 20px rgba(0,0,0,.15);
    padding:4px 0;z-index:500;display:none;min-width:160px;
}
#ctxMenu button{
    display:block;width:100%;text-align:left;
    padding:8px 14px;background:none;border:none;
    font-size:13px;cursor:pointer;border-radius:0;
}
#ctxMenu button:hover{background:#f3f4f6}
#ctxMenu button.danger{color:#dc2626}
#ctxMenu button.danger:hover{background:#fee2e2}

/* media / voice buttons */
#attachBtn,#voiceBtn{font-size:16px;padding:6px 8px;background:#f1f5f9}
#attachBtn:hover,#voiceBtn:hover{background:#e2e8f0}
#voiceBtn.recording{background:#fee2e2;color:#dc2626}
#fileInput{display:none}
</style>
</head>

<body>

<div id="authOverlay">
  <div id="authBox">
    <h2 id="authTitle">–í—Ö–æ–¥</h2>
    <input id="authNick" placeholder="–ù–∏–∫" autocomplete="username">
    <input id="authPassword" type="password" placeholder="–ü–∞—Ä–æ–ª—å" autocomplete="current-password">
    <div id="authError"></div>
    <button class="primary" id="authSubmit">–í–æ–π—Ç–∏</button>
    <div id="authSwitch">–ù–µ—Ç –∞–∫–∫–∞—É–Ω—Ç–∞? <a id="authToggle">–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è</a></div>
  </div>
</div>

<div class="app" id="appDiv" style="display:none">

<div class="panel">
<div class="top" id="myNickLabel">–í—ã: ‚Äî <button id="logoutBtn">–í—ã–π—Ç–∏</button></div>

<div style="padding:10px;border-bottom:1px solid #eee;display:flex;gap:5px">
<input id="friendName" placeholder="–ù–∏–∫ –¥—Ä—É–≥–∞" style="flex:1">
<button id="addFriend">+</button>
</div>

<div class="contacts" id="contacts"></div>
</div>

<div class="panel">
<div class="top" id="chatHeader">–ß–∞—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω</div>
<div class="messages" id="messages"></div>

<div class="composer">
<input id="messageInput" style="flex:1" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ">
<button id="attachBtn" title="–ü—Ä–∏–∫—Ä–µ–ø–∏—Ç—å —Ñ–∞–π–ª">üìé</button>
<input type="file" id="fileInput" accept="image/*,video/*,audio/*">
<button id="voiceBtn" title="–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ">üé§</button>
<button class="primary" id="sendBtn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
<button id="callBtn">üìû</button>
</div>
</div>

</div>

<div class="callBox" id="callBox">
<div id="callStatus">–ó–≤–æ–Ω–æ–∫...</div>
<button id="endCall">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
</div>

<div id="incomingCall">
  <div id="incomingBox">
    <div class="caller" id="incomingCaller">–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π</div>
    <div class="sub">–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫...</div>
    <div class="call-btns">
      <button id="acceptCall">–ü—Ä–∏–Ω—è—Ç—å</button>
      <button id="rejectCall">–û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
    </div>
  </div>
</div>

<div id="ctxMenu">
  <button id="ctxClear">–û—á–∏—Å—Ç–∏—Ç—å —á–∞—Ç</button>
  <button id="ctxDelete" class="danger">–£–¥–∞–ª–∏—Ç—å –∫–æ–Ω—Ç–∞–∫—Ç</button>
</div>

<audio id="msgSound" src="message.mp3" preload="auto"></audio>
<audio id="callSound" src="call.mp3" preload="auto" loop></audio>

<script>
let socket;
let myName = "";
let authMode = "login";
let state = JSON.parse(localStorage.getItem("messenger_state") || '{"contacts":[],"conversations":{},"online":{}}');
let active = null;

let peer;
let localStream;

// voice recording
let mediaRecorder = null;
let voiceChunks = [];

const contactsEl = document.getElementById("contacts");
const messagesEl = document.getElementById("messages");
const chatHeader = document.getElementById("chatHeader");
const msgSound = document.getElementById("msgSound");
const callBox = document.getElementById("callBox");
const authOverlay = document.getElementById("authOverlay");
const appDiv = document.getElementById("appDiv");
const authError = document.getElementById("authError");
const authTitle = document.getElementById("authTitle");
const authSubmit = document.getElementById("authSubmit");
const authToggle = document.getElementById("authToggle");
const authSwitch = document.getElementById("authSwitch");
const voiceBtn = document.getElementById("voiceBtn");
const fileInput = document.getElementById("fileInput");
const callSound = document.getElementById("callSound");
const incomingCall = document.getElementById("incomingCall");
const incomingCaller = document.getElementById("incomingCaller");

// pending incoming offer ‚Äî stored until user accepts/rejects
let pendingOffer = null;

function save() { localStorage.setItem("messenger_state", JSON.stringify(state)); }

function formatTime(ts) {
    if (!ts) return "";
    const d = new Date(ts);
    const now = new Date();
    const pad = n => String(n).padStart(2, "0");
    const time = pad(d.getHours()) + ":" + pad(d.getMinutes());
    if (d.toDateString() === now.toDateString()) return time;
    return pad(d.getDate()) + "." + pad(d.getMonth() + 1) + " " + time;
}

function renderMessageEl(m) {
    const wrap = document.createElement("div");
    wrap.className = "message " + (m.from === myName ? "me" : "them");

    if (m.mediaType && m.mediaData) {
        const media = document.createElement("div");
        media.className = "msg-media";
        if (m.mediaType.startsWith("image/")) {
            const img = document.createElement("img");
            img.src = "data:" + m.mediaType + ";base64," + m.mediaData;
            img.alt = m.fileName || "image";
            media.appendChild(img);
        } else if (m.mediaType.startsWith("video/")) {
            const vid = document.createElement("video");
            vid.src = "data:" + m.mediaType + ";base64," + m.mediaData;
            vid.controls = true;
            media.appendChild(vid);
        } else if (m.mediaType.startsWith("audio/")) {
            const aud = document.createElement("audio");
            aud.src = "data:" + m.mediaType + ";base64," + m.mediaData;
            aud.controls = true;
            media.appendChild(aud);
        } else {
            // generic file ‚Äî download link
            const a = document.createElement("a");
            const blob = b64toBlob(m.mediaData, m.mediaType);
            a.href = URL.createObjectURL(blob);
            a.download = m.fileName || "file";
            a.textContent = "üìÑ " + (m.fileName || "file");
            a.style.cssText = "color:#2563eb;font-size:13px";
            media.appendChild(a);
        }
        wrap.appendChild(media);
    } else {
        const txt = document.createElement("span");
        txt.textContent = m.text || "";
        wrap.appendChild(txt);
    }

    const time = document.createElement("span");
    time.className = "msg-time";
    time.textContent = formatTime(m.ts);
    wrap.appendChild(time);

    return wrap;
}

function b64toBlob(b64, type) {
    const bytes = atob(b64);
    const arr = new Uint8Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) arr[i] = bytes.charCodeAt(i);
    return new Blob([arr], { type });
}

function renderContacts() {
    contactsEl.innerHTML = "";
    state.contacts.forEach(name => {
        let d = document.createElement("div");
        d.className = "contact";
        d.innerHTML = `
            <span>${name}</span>
            <span class="${state.online[name] ? "online" : "offline"}">
                ${state.online[name] ? "‚óè online" : "‚óè offline"}
            </span>
        `;
        d.onclick = () => {
            active = name;
            chatHeader.textContent = "–ß–∞—Ç —Å " + name;
            renderMessages();
        };
        d.oncontextmenu = e => {
            e.preventDefault();
            showCtxMenu(e.clientX, e.clientY, name);
        };
        contactsEl.appendChild(d);
    });
}

function renderMessages() {
    messagesEl.innerHTML = "";
    if (!active) return;
    const conv = state.conversations[active] || [];
    conv.forEach(m => messagesEl.appendChild(renderMessageEl(m)));
    messagesEl.scrollTop = messagesEl.scrollHeight;
}

function appendMessage(m) {
    if (active === (m.from === myName ? m.to : m.from)) {
        messagesEl.appendChild(renderMessageEl(m));
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
}

function sendMsg(msg) {
    if (!state.conversations[msg.to]) state.conversations[msg.to] = [];
    state.conversations[msg.to].push(msg);
    socket.send(JSON.stringify(msg));
    save();
    appendMessage(msg);
}

function mainMessageHandler(e) {
    let data;
    try { data = JSON.parse(e.data); } catch { return; }

    if (data.type === "kicked") {
        alert("–í—ã –≤–æ—à–ª–∏ —Å –¥—Ä—É–≥–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.");
        location.reload();
        return;
    }

    if (data.type === "onlineList") {
        state.online = data.users;
        save(); renderContacts();
    }

    if (data.type === "message") {
        const from = data.from;
        if (!state.conversations[from]) state.conversations[from] = [];
        state.conversations[from].push(data);
        if (!state.contacts.includes(from)) state.contacts.push(from);
        msgSound.play();
        save(); renderContacts();
        appendMessage(data);
    }

    if (data.type === "signal") {
        handleSignal(data);
    }
}

function connectAndAuth() {
    const nick = document.getElementById("authNick").value.trim();
    const password = document.getElementById("authPassword").value;
    authError.textContent = "";

    if (!nick || !password) {
        authError.textContent = "–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è";
        return;
    }

    authSubmit.disabled = true;

    const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
    socket = new WebSocket(wsUrl);

    socket.onopen = () => {
        socket.send(JSON.stringify({ type: authMode, nick, password }));
    };

    socket.onmessage = e => {
        let data;
        try { data = JSON.parse(e.data); } catch { return; }

        if (data.type === "authResult") {
            if (data.success) {
                myName = data.nick;
                document.getElementById("myNickLabel").firstChild.textContent = "–í—ã: " + myName + " ";
                authOverlay.style.display = "none";
                appDiv.style.display = "grid";
                socket.onmessage = mainMessageHandler;
            } else {
                authError.textContent = data.error || "–û—à–∏–±–∫–∞";
                authSubmit.disabled = false;
                socket.close();
            }
        }
    };

    socket.onerror = () => {
        authError.textContent = "–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É";
        authSubmit.disabled = false;
    };
}

authSubmit.onclick = connectAndAuth;
document.getElementById("authNick").addEventListener("keydown", e => {
    if (e.key === "Enter") connectAndAuth();
});
document.getElementById("authPassword").addEventListener("keydown", e => {
    if (e.key === "Enter") connectAndAuth();
});

authToggle.onclick = () => {
    if (authMode === "login") {
        authMode = "register";
        authTitle.textContent = "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è";
        authSubmit.textContent = "–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è";
        authSwitch.innerHTML = '–£–∂–µ –µ—Å—Ç—å –∞–∫–∫–∞—É–Ω—Ç? <a id="authToggle">–í–æ–π—Ç–∏</a>';
    } else {
        authMode = "login";
        authTitle.textContent = "–í—Ö–æ–¥";
        authSubmit.textContent = "–í–æ–π—Ç–∏";
        authSwitch.innerHTML = '–ù–µ—Ç –∞–∫–∫–∞—É–Ω—Ç–∞? <a id="authToggle">–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è</a>';
    }
    authError.textContent = "";
    document.getElementById("authToggle").onclick = authToggle.onclick;
};

// --- Send text ---
document.getElementById("sendBtn").onclick = () => {
    if (!active) return;
    const text = document.getElementById("messageInput").value.trim();
    if (!text) return;
    const msg = { type: "message", from: myName, to: active, text, ts: Date.now() };
    document.getElementById("messageInput").value = "";
    sendMsg(msg);
};
document.getElementById("messageInput").addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        document.getElementById("sendBtn").click();
    }
});

// --- Attach file ---
document.getElementById("attachBtn").onclick = () => {
    if (!active) return;
    fileInput.click();
};
fileInput.onchange = () => {
    const file = fileInput.files[0];
    if (!file) return;
    fileInput.value = "";

    const MAX = 10 * 1024 * 1024; // 10 MB
    if (file.size > MAX) {
        alert("–§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10 –ú–ë)");
        return;
    }

    const reader = new FileReader();
    reader.onload = ev => {
        const dataUrl = ev.target.result;
        const base64 = dataUrl.split(",")[1];
        const msg = {
            type: "message",
            from: myName,
            to: active,
            text: "",
            mediaType: file.type,
            mediaData: base64,
            fileName: file.name,
            ts: Date.now()
        };
        sendMsg(msg);
    };
    reader.readAsDataURL(file);
};

// --- Voice message ---
voiceBtn.onclick = async () => {
    if (!active) return;

    if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        return;
    }

    let stream;
    try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch {
        alert("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É");
        return;
    }

    voiceChunks = [];
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => voiceChunks.push(e.data);
    mediaRecorder.onstop = () => {
        stream.getTracks().forEach(t => t.stop());
        voiceBtn.classList.remove("recording");
        voiceBtn.title = "–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ";

        const blob = new Blob(voiceChunks, { type: mediaRecorder.mimeType || "audio/webm" });
        const reader = new FileReader();
        reader.onload = ev => {
            const base64 = ev.target.result.split(",")[1];
            const msg = {
                type: "message",
                from: myName,
                to: active,
                text: "",
                mediaType: blob.type,
                mediaData: base64,
                fileName: "voice.webm",
                ts: Date.now()
            };
            sendMsg(msg);
        };
        reader.readAsDataURL(blob);
    };

    mediaRecorder.start();
    voiceBtn.classList.add("recording");
    voiceBtn.title = "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å";
};

// --- Logout ---
document.getElementById("logoutBtn").onclick = () => {
    if (socket) socket.close();
    location.reload();
};

// --- Context menu ---
const ctxMenu = document.getElementById("ctxMenu");
let ctxTarget = null;

function showCtxMenu(x, y, name) {
    ctxTarget = name;
    ctxMenu.style.left = x + "px";
    ctxMenu.style.top = y + "px";
    ctxMenu.style.display = "block";
}
function hideCtxMenu() {
    ctxMenu.style.display = "none";
    ctxTarget = null;
}

document.addEventListener("click", hideCtxMenu);
document.addEventListener("keydown", e => { if (e.key === "Escape") hideCtxMenu(); });

document.getElementById("ctxClear").onclick = () => {
    if (!ctxTarget) return;
    state.conversations[ctxTarget] = [];
    save();
    if (active === ctxTarget) renderMessages();
    hideCtxMenu();
};
document.getElementById("ctxDelete").onclick = () => {
    if (!ctxTarget) return;
    state.contacts = state.contacts.filter(c => c !== ctxTarget);
    delete state.conversations[ctxTarget];
    if (active === ctxTarget) {
        active = null;
        chatHeader.textContent = "–ß–∞—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω";
        renderMessages();
    }
    save(); renderContacts();
    hideCtxMenu();
};

// --- Add friend ---
document.getElementById("addFriend").onclick = () => {
    let f = document.getElementById("friendName").value.trim();
    if (!f) return;
    if (!state.contacts.includes(f)) state.contacts.push(f);
    document.getElementById("friendName").value = "";
    save(); renderContacts();
};

// --- Call ---
function stopCallSound() {
    callSound.pause();
    callSound.currentTime = 0;
}

function endActiveCall() {
    if (peer) { peer.close(); peer = null; }
    if (localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; }
    stopCallSound();
    callBox.style.display = "none";
}

async function startCall() {
    if (!active) return;
    peer = createPeer(active);
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    localStream.getTracks().forEach(t => peer.addTrack(t, localStream));
    const offer = await peer.createOffer();
    await peer.setLocalDescription(offer);
    socket.send(JSON.stringify({ type: "signal", from: myName, to: active, data: offer }));
    document.getElementById("callStatus").textContent = "–û–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞...";
    callBox.style.display = "block";
}

function createPeer(callTarget) {
    const pc = new RTCPeerConnection();
    pc.onicecandidate = e => {
        if (e.candidate) {
            socket.send(JSON.stringify({ type: "signal", from: myName, to: callTarget, data: e.candidate }));
        }
    };
    pc.ontrack = e => {
        const audio = new Audio();
        audio.srcObject = e.streams[0];
        audio.play();
    };
    pc.onconnectionstatechange = () => {
        if (pc.connectionState === "connected") {
            document.getElementById("callStatus").textContent = "–ó–≤–æ–Ω–æ–∫ —Å " + callTarget;
        }
    };
    return pc;
}

async function handleSignal(data) {
    if (data.data.type === "offer") {
        // Store offer and show incoming call UI
        pendingOffer = data;
        incomingCaller.textContent = data.from;
        incomingCall.style.display = "flex";
        callSound.play().catch(() => {});

    } else if (data.data.type === "answer") {
        if (!peer) return;
        stopCallSound();
        await peer.setRemoteDescription(new RTCSessionDescription(data.data));
        document.getElementById("callStatus").textContent = "–ó–≤–æ–Ω–æ–∫...";

    } else if (data.data === "rejected") {
        stopCallSound();
        endActiveCall();
        document.getElementById("callStatus").textContent = "–ó–≤–æ–Ω–æ–∫ –æ—Ç–∫–ª–æ–Ω—ë–Ω";

    } else {
        // ICE candidate
        if (peer) {
            try { await peer.addIceCandidate(new RTCIceCandidate(data.data)); } catch {}
        }
    }
}

document.getElementById("acceptCall").onclick = async () => {
    if (!pendingOffer) return;
    const data = pendingOffer;
    pendingOffer = null;
    incomingCall.style.display = "none";
    stopCallSound();

    active = data.from;
    chatHeader.textContent = "–ß–∞—Ç —Å " + active;

    peer = createPeer(data.from);
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    localStream.getTracks().forEach(t => peer.addTrack(t, localStream));

    await peer.setRemoteDescription(new RTCSessionDescription(data.data));
    const answer = await peer.createAnswer();
    await peer.setLocalDescription(answer);
    socket.send(JSON.stringify({ type: "signal", from: myName, to: data.from, data: answer }));

    document.getElementById("callStatus").textContent = "–ó–≤–æ–Ω–æ–∫ —Å " + data.from;
    callBox.style.display = "block";
};

document.getElementById("rejectCall").onclick = () => {
    if (!pendingOffer) return;
    const from = pendingOffer.from;
    pendingOffer = null;
    incomingCall.style.display = "none";
    stopCallSound();
    socket.send(JSON.stringify({ type: "signal", from: myName, to: from, data: "rejected" }));
};

document.getElementById("callBtn").onclick = startCall;
document.getElementById("endCall").onclick = () => {
    endActiveCall();
};

renderContacts();
</script>

</body>
</html>
